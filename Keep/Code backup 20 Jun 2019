/*
 MIDI note player

 Arduino Mega 
   USB                  Computer
   Pin 16 (Serial2 out) MIDI synth
   Pin 17 (Serial2  in) Keyboard
   Pin 19 (Serial1  in) Roland GL-10
   
 The circuit:
 * digital in 1 connected to MIDI jack pin 5
 * MIDI jack pin 2 connected to ground
 * MIDI jack pin 4 connected to +5V through 220-ohm resistor
 */
 
// Global variables
struct Event {
  int b; //byte count for synth
  int c; //Command
  int p; //Pitch
  int v; //Velocity
};
const int EventSize = 400; //Max size of the array.
                           //Could be up to 750
//const int EventSize = 750; //Max size of the array.
const int GetCount = 200; //0xC8
struct Event Events[EventSize]; 

long EventsUsed = 0;
String SerStr1, SerStr2; 
const int led = 35; //Pin 35 has an LED connected for debugging.

const int bPin2 = 2;
const int bPin3 = 3;
const int bPin4 = 4;
unsigned long bGreyTill2 = 0;
unsigned long bGreyTill3 = 0;
unsigned long bGreyTill4 = 0;
int midiPot0Pc = 0;
int midiPot1Pc = 0;

float SpeedFactor = 1; //can be altered by right-hand pot

int eIndexH = 15; //Index to the Events array head. The   
                  //end of the practice array below
int eIndexT = 0; //Index to the Events array tail.
                //Next one to be played
boolean PlayingAuto = false;
boolean PlayingTrig = false;
byte ThisVel = 0; //Velocity of note just played
byte bCount = 0;
long TimeNextEvent = 0; //In milliseconds

boolean KeyboardIsTrigger = true;
boolean GuitarIsTrigger  = true;
long SinceLastTrigger = 0;
long LastTrigger = 0;

void setup() {                
  //Init the digital led pin as an output.
  pinMode(led, OUTPUT);  
  //Buttons on the Sparkfun midi shield  
  pinMode(bPin2, INPUT_PULLUP); //No external resister needed
  pinMode(bPin3, INPUT_PULLUP); 
  pinMode(bPin4, INPUT_PULLUP); 
  //digitalWrite(led, LOW);
  digitalWrite(led, HIGH);
  Serial.begin(9600);   //Serial with computer
  Serial1.begin(31250); //Serial from Roland GL-10 in
  Serial2.begin(31250); //Set MIDI baud rate. 
                        //Keyboard In, Roland SC-88 out
  
  
//Some sample data for use with when developing
//Two triggers for timing
  Events[0].b = 0x00; 
  Events[0].c = 0x00; //Delta trigger time
  Events[0].p = 0x03;
  Events[0].v = 0x20;

  Events[1].b = 0x03; 
  Events[1].c = 0x80; //Silent C
  Events[1].p = 0x3C;
  Events[1].v = 0x00;

  Events[2].b = 0x00; 
  Events[2].c = 0x00; //Delta trigger time
  Events[2].p = 0x03;
  Events[2].v = 0x20;

  Events[3].b = 0x03; 
  Events[3].c = 0x80; //Silent C
  Events[3].p = 0x3C;
  Events[3].v = 0x00;

  //Events[4].b = 0x00; 
  //Events[4].c = 0x00; //Initial delta time
  //Events[4].p = 0x03;
  //Events[4].v = 0x20;

  Events[4].b = 0x00; 
  Events[4].c = 0x00; //Initial delta time
  Events[4].p = 0x01;
  Events[4].v = 0x90;

  Events[5].b = 0x03; //Bytes for synth
  Events[5].c = 0x90; //For playing middle C
  Events[5].p = 0x3C; //C3
  Events[5].v = 0x50; //Velocity
  
  Events[6].b = 0x00; 
  Events[6].c = 0x00; //Next delta time
  Events[6].p = 0x01;
  Events[6].v = 0x90;
  
  Events[7].b = 0x03; //Bytes for synth
  Events[7].c = 0x80; //For Stoping middle C
  Events[7].p = 0x3C;
  Events[7].v = 0x00;  

  Events[8].b = 0x03; //Bytes for synth
  Events[8].c = 0x90; //For playing D
  Events[8].p = 0x3E;
  Events[8].v = 0x50;
  
  Events[9].b = 0x00; 
  Events[9].c = 0x00; //Next delta time
  Events[9].p = 0x06;
  Events[9].v = 0x40;
  
  Events[10].b = 0x03; //Bytes for synth
  Events[10].c = 0x80; //For Stoping D
  Events[10].p = 0x3E;
  Events[10].v = 0x00;  

  Events[11].b = 0x03; //Bytes for synth
  Events[11].c = 0x90; //For playing middle C
  Events[11].p = 0x3C; //C3
  Events[11].v = 0x50; //Velocity
  
  Events[12].b = 0x03; //Bytes for synth
  Events[12].c = 0x90; //For playing E3
  Events[12].p = 0x40; //E3
  Events[12].v = 0x50; //Velocity

  Events[13].b = 0x00;
  Events[13].c = 0x00; //Delta time
  Events[13].p = 0x00; 
  Events[13].v = 0x00; 
  
  Events[14].b = 0x03; //Bytes for synth
  Events[14].c = 0x80; //For stopping middle C
  Events[14].p = 0x3C; //C3
  Events[14].v = 0x00; //Velocity
  
  Events[15].b = 0x03; //Bytes for synth
  Events[15].c = 0x80; //For stopping E
  Events[15].p = 0x40; //E3
  Events[15].v = 0x00; //Velocity      
}


long GetDeltaTime(int Index) {
//Three bytes of the array record c,p, and v are used to 
//make up the time
  //Serial.println(Index);
  //Serial.println(Events[Index].c);
  long Hold = Events[Index].c;
  Hold = Hold * 65536; //Shift left
  Hold = Hold + Events[Index].p * 256;
  Hold = Hold + Events[Index].v;
  //This can be proportionally altered by the left-hand pot
  Hold = Hold * SpeedFactor;
  return Hold;
}

byte HexStrToByte(String aStr, byte Numb) {
//The length of the string will usully be a packet of 8 char
//containing 4 bytes of Hex
char aChar;
byte nybl1, nybl2, theByte;
  Numb = (Numb * 2) - 2;
  aChar = aStr[Numb]; //Zero based
  //Serial.println(aChar);
  
  nybl1 = aChar;
  if (nybl1 > 64) {
    nybl1 = nybl1 - 55;
  }  
  else {
    nybl1 = nybl1 -48;
  }
  nybl1 = nybl1 * 16;
  //Serial.println(nybl1);
  
  //Now the least signif nybble
  Numb = Numb + 1;
  aChar = aStr[Numb]; //Zero based
  //Serial.println(aChar);
  
  nybl2 = aChar;
  if (nybl2 > 64) {
    nybl2 = nybl2 - 55;
  }  
  else {
    nybl2 = nybl2 -48;
  }
  //Serial.println(nybl2);
  theByte = nybl1 + nybl2;
  //Serial.println(theByte);
  return theByte;
}


void incIndex(char Which) {
  //inc eIndexH or eIndex T?
  //Each index pointer moves contiguously from 0 to 
  //EventSize, and then loops back
  switch (Which) {
  case 'T':
    EventsUsed = EventsUsed + 1;
    eIndexT = eIndexT + 1;    
    if (eIndexT == eIndexH + 1) { //Tortoise passes Hare
      MuteAllChannels();
      PlayingAuto = false;
      eIndexH = -1;
      eIndexT = 0;
      EventsUsed = 0;
      //String aStr = String(EventSize, HEX);
      String aStr = "200z0190"; // + aStr; //Ask for first records
      //Will get 400 initially, 200 after that
      Serial.println(aStr);      
    }
    if (eIndexT > EventSize - 1) { //Means we've overshot the array
      eIndexT = 0; //Wrap
      //break;
    }  
    if  ((eIndexH == 199) && (eIndexT == 0)) {
      //String aStr = String(GetCount, HEX);
      String aStr = "201z00C8"; //+ aStr; //Ask for next lot of records
      //Got 400 initially, 200 after that
      Serial.println(aStr);
      //break;
    }  
    if  ((eIndexH == 399) && (eIndexT == 200)) {
      //String aStr = String(GetCount, HEX);
      String aStr = "201z00C8"; //+ aStr; //Ask for next lot of records
      Serial.println(aStr);
    }  
    break;

  case 'H': 
    eIndexH = eIndexH + 1;  
    if (eIndexH == EventSize)  
      eIndexH = 0; //Wrap
    break;
  }
}

void ToggleLed() {
  digitalWrite(led, !digitalRead(led));  
}

void PeekPokePort(String aStr) {
byte PeekOrPoke;
byte PortNumb;
byte OnOff;
int val;

  PeekOrPoke = HexStrToByte(aStr, 2);
  PortNumb = HexStrToByte(aStr, 3);
  switch (PeekOrPoke) {
    case 0: //It's a peek
      //Serial.println("Here");
      val = analogRead(A0); //Read twice to prevent jitters
      val = analogRead(A0);
      SpeedFactor = map(val, 0, 1023, 500, 1999);
      //Half as fast, to twice as fast
      SpeedFactor = SpeedFactor / 1000;
      Serial.println(SpeedFactor);
      break;
    case 1: //It's a poke
      OnOff = HexStrToByte(aStr, 4); //Byte 4
      digitalWrite(PortNumb, OnOff);  
      break; 
  }
  
  //Serial.print("Port no ");
  //Serial.println(PortNumb);
  
  //Serial.print("with "); 
  //Serial.println(OnOff);
  
  //String bStr = "43";
  //int aInt = bStr.toInt();
  //Serial.println(aInt * 2);
  
}

void SendNote(int Index) {
//Plays a MIDI note. Doesn't check to see that
//cmd is greater than 127, or that data 
//values are less than 127:
int Many = Events[Index].b;

  //String aStr = String(Events[Index].b, HEX);
  //aStr = aStr + String(Events[Index].c, HEX);
  //aStr = aStr + String(Events[Index].p, HEX);
  //aStr = aStr + String(Events[Index].v, HEX);
  //Serial.println(aStr);  

  switch(Many) {
    case 1:
      Serial2.write(Events[eIndexT].c);
    case 2:
      Serial2.write(Events[eIndexT].c);    
      Serial2.write(Events[eIndexT].p);
    case 3:
      Serial2.write(Events[eIndexT].c);    
      Serial2.write(Events[eIndexT].p);
      Serial2.write(Events[eIndexT].v);
  }   
}

void MuteAllChannels() {
int Channel;  
char aChr;
String aStr;
  for (Channel = 0; Channel <= 15; Channel++) {
    if (Channel < 10) aChr = Channel + 48;
    else aChr = Channel + 55;
    aStr = "13B" + String(aChr) + "7B00";
    StraightTo88(aStr);
  }
}

void PokeEventArray(String aStr) {
  incIndex('H'); //Ahead to the next one
  Events[eIndexH].b = HexStrToByte(aStr, 1);
  Events[eIndexH].c = HexStrToByte(aStr, 2);
  Events[eIndexH].p = HexStrToByte(aStr, 3);
  Events[eIndexH].v = HexStrToByte(aStr, 4);
}


void PlayEventsAuto() {
long DeltaTime = 0;
  if (PlayingAuto == false) {
    return;
  }  
  if (millis() >= TimeNextEvent) {
    //Get set for the TimeNextEvent
    DeltaTime = GetDeltaTime(eIndexT);
    TimeNextEvent = TimeNextEvent + DeltaTime;
    incIndex('T'); //Get past timing record
    if (PlayingAuto == false) {
      return;
    }  
    while (Events[eIndexT].b != 0) {
      //Play uninterrupted the current batch of notes
      SendNote(eIndexT);
      incIndex('T'); //Ahead to the next one
      if (PlayingAuto == false) {
        return;
      }  
    }
  }
}


void CheckMidiPots() {
int val;
//String aStr;
  val = analogRead(A0); //Read twice to prevent jitters
  val = analogRead(A0);
  SpeedFactor = map(val, 0, 1023, 500, 1999);
  //Half as fast, to twice as fast
  SpeedFactor = SpeedFactor / 1000;
  //aStr = String(midiPot0Pc, HEX);
  //Serial.println(aStr);    
}


void CheckButtons() {
String aStr = "No Press"; 
int bRead;
  if (millis() >= bGreyTill2) {
    bRead = digitalRead(bPin2);
      //Left button. Stop and reload
    if (bRead == LOW) {
      bGreyTill2 = millis() + 500; //Set debounce time
      //TimeNextEvent = millis(); 
      MuteAllChannels();
      EventsUsed = 0;
      PlayingAuto = false;
      eIndexH = -1;
      eIndexT = 0;
      //String aStr = String(EventSize, HEX);
      aStr = "200z0190"; //+ aStr; //Ask for first records
      //Will get 400 initially, 200 after that
      Serial.println(aStr);
    }
  }
  if (millis() >= bGreyTill3) {
    bRead = digitalRead(bPin3); 
      //Middle button. Play or resume
    if (bRead == LOW) {
      bGreyTill3 = millis() + 500; //Set debounce time
      TimeNextEvent = millis(); 
      PlayingAuto = true;
      //Get past the initial count-in-tap records
      //if (eIndexT == 0) { //Only at the beginning
      //  incIndex('T'); incIndex('T'); 
      //  incIndex('T'); incIndex('T'); }
    }
  }
  if (millis() >= bGreyTill4) {
    //Right button. Pause, and reset all contollers. ie. Mute.
    bRead = digitalRead(bPin4);
      //Pause, and reset all contollers. ie. Mute.
    if (bRead == LOW) {
      bGreyTill4 = millis() + 500; //Set debounce time
      PlayingAuto = false;
      Serial.println("Paused");
      
      MuteAllChannels();
      //for (int Channel = 0; Channel <= 15; Channel++) {
      //  aStr = "13B" + String(Channel, HEX) + "7B00";
      //  StraightTo88(aStr);
      //}
    }
  }
}

void StraightTo88(String aStr) {
char Many;
byte aByte;

  Many = aStr[1];
  switch(Many) {
    case '1':
      Serial2.write(HexStrToByte(aStr,2));
    case '2':
      Serial2.write(HexStrToByte(aStr, 2));    
      Serial2.write(HexStrToByte(aStr, 3));
    case '3':
      Serial2.write(HexStrToByte(aStr, 2));    
      Serial2.write(HexStrToByte(aStr, 3));
      Serial2.write(HexStrToByte(aStr, 4));
  }   
}


void PacketComplete(String SerStr) {
//Direct program flow
String aStr;
char aChr;
  //Serial.println(SerStr);
  aChr = SerStr[0];
  //Serial.println(aChr);
  switch (aChr) {
  case '0': //something for arduino to do
    aChr = SerStr[1];
    switch (aChr) { //Second char in SerStr
    case '0' ... '3':
      PokeEventArray(SerStr);
      break;
    case '4': //Play, or pause
      aChr = SerStr[2]; //Third char
      switch (aChr) {
      case '0': //040  Pause
        MuteAllChannels();
        PlayingAuto = false;
        Serial.println("Events used "  + (String(EventsUsed)));
        break;
      case '1': //041  Play the event array
        TimeNextEvent = millis(); 
        PlayingAuto = true;
        break;
      }
      break;
    case '5': //Peek or poke a port 
      //Serial.println("Port set"); 
      PeekPokePort(SerStr);
      break;
    case '6':
      aChr = SerStr[2]; //Third char
      switch (aChr) {
      case '0': //060  Reset event array pointers
        eIndexH = -1;
        eIndexT = 0;
        //Get number from the packet mark
        EventsUsed = HexStrToByte(SerStr, 2) * 65536; 
        EventsUsed = EventsUsed + (HexStrToByte(SerStr, 3) * 256); 
        EventsUsed = EventsUsed + HexStrToByte(SerStr, 4); 
        break;
      }  
    } //End inside switch
    break;
  case '1': //Sending straight to SC-88
    //First char in SerStr 
    //digitalWrite(led, HIGH);
    //Serial.println("Here 1");
    StraightTo88(SerStr);
    break;
  case '3': //Directing keyboard's data
    aChr = SerStr[1];
    switch (aChr) {
    case '0':
      KeyboardIsTrigger = false;
      digitalWrite(led, LOW);
      break;
    case '1':  
      KeyboardIsTrigger = true;
      digitalWrite(led, HIGH);
      break;
    }  
  break;  
    
  case '4': //Directing guitar's data
    aChr = SerStr[1];
    switch (aChr) {
    case '0':
      GuitarIsTrigger = false;
      digitalWrite(led, LOW);
      break;
    case '1':  
      GuitarIsTrigger = true;
      digitalWrite(led, HIGH);
      break;
    }  
    break;
  } //End outside switch
}


void CheckIncoming() { //From computer
String aStr;
  if (Serial.available() > 0) {
    char ChrRead = Serial.read();
    SerStr1 = SerStr1 + ChrRead;
    //Serial.println(SerStr1.length());
    if (SerStr1.length() > 7) {
      //Serial.println(SerStr1);
      PacketComplete(SerStr1);
      SerStr1 = "";
    }  
  }

  
  if (Serial1.available() > 0) { //From Roland GL-10 guitar
    char GuitarRead = Serial1.read();
    if (!GuitarIsTrigger) {
      Serial2.write(GuitarRead);
      goto Dont;}
    aStr = String(GuitarRead, HEX);  
    if (aStr == "fffe") { //Constant stream of this stuff from guitar
      goto Dont;}
    if (aStr.substring(0, 3) == "ff9") {
      //SerStr2 = aStr;
      bCount = 1;
      goto Dont;}
    if (bCount == 1) {
      //SerStr2 = SerStr2 + aStr;
      bCount = 2;
      goto Dont;}
    if (bCount == 2) {
      //SerStr2 = ""; 
      //This third byte is the velocity
      ThisVel = GuitarRead;
      bCount = 0;
      if (ThisVel == 0) { //Note-on cmd, but zero vel
        goto Dont;}
      incIndex('T'); //Gets past timing record
      while (Events[eIndexT].b != 0) { //Send this group
        if ((Events[eIndexT].c > 0x8F) && (Events[eIndexT].c < 0xA0))
          //For note cmds, modifying the velocity
          Events[eIndexT].v = ThisVel;
        SendNote(eIndexT);
        incIndex('T'); 
      }  
    }
Dont:
    aStr = ""; //Need something after a label
  } 
  
  
  if (Serial2.available() > 0) { //From music keyboard
    char KbdRead = Serial2.read();
    if (!KeyboardIsTrigger) {
      Serial2.write(KbdRead);
      goto DoNot;}
    aStr = String(KbdRead, HEX);  
    //if (aStr == "fffe") { //Constant stream of this stuff from guitar
    //  goto DoNot;}
    if (aStr.substring(0, 3) == "ff9") {
      SerStr2 = aStr;
      bCount = 1;
      goto DoNot;}
    if (bCount == 1) {
      SerStr2 = SerStr2 + aStr;
      bCount = 2;
      goto DoNot;}
    if (bCount == 2) { 
      SerStr2 = SerStr2 + aStr;
      //Serial.println(SerStr2);
      
      SinceLastTrigger = millis() - LastTrigger;
      LastTrigger = millis();
      SerStr2 = ""; //This third byte is the velocity
      ThisVel = KbdRead;
      bCount = 0;
      if (ThisVel == 0) {//Note on cmd, but zero vel
        goto DoNot;}
      ToggleLed();
      PlayingTrig = true;
      
      incIndex('T'); //Gets past timing record
      while (Events[eIndexT].b != 0) { //Send this group
        if ((Events[eIndexT].c > 0x8F) && (Events[eIndexT].c < 0xA0)) {
          //Serial.println("Times");
          //For note on cmds only, modifying the velocity
          Events[eIndexT].v = ThisVel;
          
        }  
        SendNote(eIndexT);
        incIndex('T'); 
      }  
    }
DoNot:
    aStr = ""; //Need something after a label
  } 
}

void loop() {
  CheckIncoming();
  PlayEventsAuto();
  CheckMidiPots();
  CheckButtons();
}



unit Unit1;

{$mode objfpc}{$H+}

interface

uses
  Classes, Serial, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,
  Grids, ExtCtrls, ComCtrls, Menus, StrUtils, DateUtils, LCLTYPE;

type

  { TForm1 }

  TForm1 = class(TForm)
    btnLoadMidiFile: TButton;
    btnMakeNoteList: TButton;
    btnOn: TButton;
    btnOff: TButton;
    btnParseArray: TButton;
    btnPlayNoteList: TButton;
    btnQuickStart: TButton;
    btnSave: TButton;
    btnSend: TButton;
    btnSortNoteList: TButton;
    btnStartArduino: TButton;
    btnStop: TButton;
    btnToSC89: TButton;
    btnLoadNoteList: TButton;
    btnPause: TButton;
    btnFind: TButton;
    btnFindNote: TButton;
    btnPollAnalog: TButton;
    btnFindNoteInList: TButton;
    btnSoundOff: TButton;
    btnQuickLoad: TButton;
    btnGetChInst: TButton;
    btnChangeUsedChannel: TButton;
    cbPatch: TComboBox;
    edFind: TEdit;
    edFIndNote: TEdit;
    edFindNoteInList: TEdit;
    edStartEvent: TEdit;
    labChInst1: TLabel;
    labChInst10: TLabel;
    labChInst11: TLabel;
    labChInst12: TLabel;
    labChInst13: TLabel;
    labChInst14: TLabel;
    labChInst15: TLabel;
    labChInst2: TLabel;
    labChInst3: TLabel;
    labChInst4: TLabel;
    labChInst5: TLabel;
    labChInst6: TLabel;
    labChInst7: TLabel;
    labChInst8: TLabel;
    labChInst9: TLabel;
    Label1: TLabel;
    labAttrib: TLabel;
    labChInst0: TLabel;
    Label2: TLabel;
    Label3: TLabel;
    Label4: TLabel;
    labVol0: TLabel;
    labVol1: TLabel;
    labVolA: TLabel;
    labVol2: TLabel;
    labVol3: TLabel;
    labVol4: TLabel;
    labVol5: TLabel;
    labVol6: TLabel;
    labVol7: TLabel;
    labVol8: TLabel;
    labVol9: TLabel;
    labVolB: TLabel;
    labVolC: TLabel;
    labVolD: TLabel;
    labVolE: TLabel;
    labVolF: TLabel;
    labVolume: TLabel;
    labFineVolume: TLabel;
    labInst1: TLabel;
    labInst2: TLabel;
    labInst3: TLabel;
    labStarted: TLabel;
    labStatus: TLabel;
    lbReceived: TListBox;
    OpenDialog1: TOpenDialog;
    PageControl1: TPageControl;
    rbPhas: TRadioButton;
    rbDel: TRadioButton;
    rbCho: TRadioButton;
    rbTrem: TRadioButton;
    rbRev: TRadioButton;
    rbVDel: TRadioButton;
    rbVdep: TRadioButton;
    rbVra: TRadioButton;
    rbDec: TRadioButton;
    rbFil: TRadioButton;
    rbAtt: TRadioButton;
    rbRel: TRadioButton;
    rbTim: TRadioButton;
    rbVar: TRadioButton;
    rgAttrib: TRadioGroup;
    rbCh16: TRadioButton;
    rbCh15: TRadioButton;
    rbCh14: TRadioButton;
    rbCh13: TRadioButton;
    rbCh12: TRadioButton;
    rbCh11: TRadioButton;
    rbCh10: TRadioButton;
    rbCh09: TRadioButton;
    rbCh08: TRadioButton;
    rbCh07: TRadioButton;
    rbCh06: TRadioButton;
    rbCh05: TRadioButton;
    rbCh04: TRadioButton;
    rbCh03: TRadioButton;
    rbCh02: TRadioButton;
    rbCh01: TRadioButton;
    rgChan1: TRadioGroup;
    rgKeyboard: TRadioGroup;
    rgGuitar: TRadioGroup;
    sgEventTable: TStringGrid;
    sgMidiTable: TStringGrid;
    TabSheet1: TTabSheet;
    TabSheet2: TTabSheet;
    TabSheet3: TTabSheet;
    TabSheet4: TTabSheet;
    TabSheet5: TTabSheet;
    UpDn1: TUpDown;
    UpDn2: TUpDown;
    UpDn3: TUpDown;


    procedure btnChangeUsedChannelClick(Sender: TObject);
    procedure GetChInst();
    procedure btnGetChInstClick(Sender: TObject);
    procedure labFineVolumeClick(Sender: TObject);
    procedure labVolumeClick(Sender: TObject);
    procedure OnProgramStart(Sender: TObject);
    procedure AllSoundOff(Sender: TObject);
    procedure btnFindClick(Sender: TObject);
    procedure btnFindNoteClick(Sender: TObject);
    procedure labAttribClick(Sender: TObject);
    procedure LoadNoteList;
    procedure btnLoadNoteListClick(Sender: TObject);
    procedure btnOnClick(Sender: TObject);
    procedure btnOffClick(Sender: TObject);
    procedure btnPauseClick(Sender: TObject);
    procedure btnPollAnalogClick(Sender: TObject);
    procedure btnQuickLoadClick(Sender: TObject);
    procedure btnQuickStartClick(Sender: TObject);
    procedure btnSaveClick(Sender: TObject);
    procedure cbPatchChange(Sender: TObject);
    procedure FindNoteInList(Sender: TObject);
    procedure SetInstrument(Sender: TObject);
    procedure ThroughOrTrigger();
    procedure rgGuitarClick(Sender: TObject);
    procedure rgKeyboardClick(Sender: TObject);
    procedure Transmit(s: string);
    procedure SendIt;
    procedure btnSendClick(Sender: TObject);
    procedure DisplayPacket(ComIn: string);
    procedure ActionAsk(ComIn: string);
    procedure btnStartArduinoClick(Sender: TObject);
    procedure SendNote();
    procedure btnToSC88Click(Sender: TObject);
    procedure btnStopClick(Sender: TObject);
    procedure ClearReceived(Sender: TObject);
    procedure SortNoteListClick(Sender: TObject);
    function FourByteStr(b0, b1, b2, b3: byte): String;
    procedure PanTremMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
    procedure MakeAttribString;
    procedure UpDn1Click(Sender: TObject; Button: TUDBtnType);
    procedure UpDn2Click(Sender: TObject; Button: TUDBtnType);
    procedure UpDn3Click(Sender: TObject; Button: TUDBtnType);
    function VLN(var midIx: integer): LongInt;
    procedure LoadMidiFile;
    procedure LoadMidiFileClick(Sender: TObject);
    procedure DisplayEventGrid();
    procedure MakeNoteList(Sender: TObject);
    procedure PlayNoteListClick(Sender: TObject);
    procedure ParseArray(Sender: TObject);
  private
    { private declarations }
  public
    { public declarations }
  end;

  TrackType = Record
    Number: integer;
    trackStart: integer; {Where in the midi-file}
    trackEnd: integer;
    eventStart: integer; {Where in the Event array}
    eventEnd: integer;
  end;

  EventType = Record
    DeltaTime: LongInt; {The time from previous. The VLN (variable length number)}
    RunningDelta: LongInt; {Sum of previous deltas for this track}
    BytesToSend: integer;
    Byte1: byte; {Channel}
    Byte2: byte; {Note}
    Byte3: byte; {Velocity}
    Sort: integer; {The order the array is to be played}
  end;

var  {Global}
  Form1: TForm1;
  SerialHandle: LongInt;
  glSerialRunning: Boolean;
  ComIn: String;
  midiArr: array of byte;
  midArrLen: longInt;
  midArrIx: longInt; {Index to midArr}

  midiFileName: string;
  f: file of char;

  trackCount: integer;
  trackRecArray: array of TrackType;
  trackIndex: integer;

  clicksPerCrotchet: longInt; {Sometimes known as PPQ or PPQN
    pulses per quarter note}
  CrotchetsPerBar: longint;
  BeatsPerBar: integer;

  EventRecArray: array of EventType;
  //NoteRecArray: array of EventType;
  EventCount: longint;
  EventIx: longint; {Index to EventRecArray}

  LastEventIxToArduino: longint;
  //Playing: boolean;
  //TimeNextEvent: LongWord; {In milliseconds}

  MidiNoteVals: array [0..120] of string[4];
  InstArray: array [0..415-1] of string;

{const}
//  midiFileName = 'C:\George\Midi02\For Arduino01.mid';
  //midiFileName = 'C:\George\Midi02\Recorder duet.mid';
  //midiFileName = 'C:\George\Midi02\And I love her.mid';


implementation

{$R *.lfm}

{ TForm1 }


function TForm1.FourByteStr(b0, b1, b2, b3: byte): String;
{All data sent to arduino will be an 8 byte string representing
4 bytes in hex string format.}
var Hold: string;
begin
  Hold := HexStr(b0, 2) + HexStr(b1, 2) + HexStr(b2, 2) + HexStr(b3, 2);
  Result := Hold;
end;

procedure TForm1.PanTremMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
var GoodShake: integer;
    s: string;
begin
  {Just experimenting}
  //Y := Y div 2;
  GoodShake := X * 2; {Width of panel is 63, so range is 2 to 126}
  labStatus.Caption := inttostr(GoodShake);
  if glSerialRunning then
  begin
    s := '13FFB007';
    Transmit(s);
    s := '11';
    s := s + HexStr(GoodShake, 2) + 'zzzz';
    Transmit(s);
  end;
end;


procedure TForm1.MakeAttribString;
var s: String;
begin
  {Update the string for Arduino in labAttrib}
  s := '13'; {Address packet to Arduino}
  {Which channel?}
  if rbCh01.Checked then s := s + 'B0';
  if rbCh02.Checked then s := s + 'B1';
  if rbCh03.Checked then s := s + 'B2';
  if rbCh04.Checked then s := s + 'B3';
  if rbCh05.Checked then s := s + 'B4';
  if rbCh06.Checked then s := s + 'B5';
  if rbCh07.Checked then s := s + 'B6';
  if rbCh08.Checked then s := s + 'B7';
  if rbCh09.Checked then s := s + 'B8';
  if rbCh10.Checked then s := s + 'B9';
  if rbCh11.Checked then s := s + 'BA';
  if rbCh12.Checked then s := s + 'BB';
  if rbCh13.Checked then s := s + 'BC';
  if rbCh14.Checked then s := s + 'BD';
  if rbCh15.Checked then s := s + 'BE';
  if rbCh16.Checked then s := s + 'BF';

  {Which Attrib?}
  if rbVar.Checked then s := s + HexStr(rbVar.Tag, 2);
  if rbRel.Checked then s := s + HexStr(rbRel.Tag, 2);
  if rbFil.Checked then s := s + HexStr(rbFil.Tag, 2);
  if rbVra.Checked then s := s + HexStr(rbVar.Tag, 2);
  if rbVDel.Checked then s := s + HexStr(rbVDel.Tag, 2);
  if rbTrem.Checked then s := s + HexStr(rbTrem.Tag, 2);
  if rbDel.Checked then s := s + HexStr(rbDel.Tag, 2);
  if rbTim.Checked then s := s + HexStr(rbTim.Tag, 2);
  if rbAtt.Checked then s := s + HexStr(rbAtt.Tag, 2);
  if rbDec.Checked then s := s + HexStr(rbDec.Tag, 2);
  if rbVdep.Checked then s := s + HexStr(rbVdep.Tag, 2);
  if rbRev.Checked then s := s + HexStr(rbRev.Tag, 2);
  if rbCho.Checked then s := s + HexStr(rbCho.Tag, 2);
  if rbPhas.Checked then s := s + HexStr(rbPhas.Tag, 2);

  s := s + HexStr(UpDn1.Position, 2);

  labAttrib.Caption := s
end;


procedure TForm1.UpDn1Click(Sender: TObject; Button: TUDBtnType);
begin
  MakeAttribString;
end;

procedure TForm1.UpDn2Click(Sender: TObject; Button: TUDBtnType);
var s: String;
begin
  {Update the string for Arduino in labAttrib}
  s := '13'; {Address of packet to Arduino}
  {Which channel?}
  if rbCh01.Checked then s := s + 'B0';
  if rbCh02.Checked then s := s + 'B1';
  if rbCh03.Checked then s := s + 'B2';
  if rbCh04.Checked then s := s + 'B3';
  if rbCh05.Checked then s := s + 'B4';
  if rbCh06.Checked then s := s + 'B5';
  if rbCh07.Checked then s := s + 'B6';
  if rbCh08.Checked then s := s + 'B7';
  if rbCh09.Checked then s := s + 'B8';
  if rbCh10.Checked then s := s + 'B9';
  if rbCh11.Checked then s := s + 'BA';
  if rbCh12.Checked then s := s + 'BB';
  if rbCh13.Checked then s := s + 'BC';
  if rbCh14.Checked then s := s + 'BD';
  if rbCh15.Checked then s := s + 'BE';
  if rbCh16.Checked then s := s + 'BF';

  {Which Attrib?}
  s := s + '0B';
  s := s + HexStr(UpDn2.Position, 2);

  labFineVolume.Caption := s

end;

procedure TForm1.UpDn3Click(Sender: TObject; Button: TUDBtnType);
var s: String;
begin
  {Update the string for Arduino in labAttrib}
  s := '13'; {Address of packet to Arduino}
  {Which channel?}
  if rbCh01.Checked then s := s + 'B0';
  if rbCh02.Checked then s := s + 'B1';
  if rbCh03.Checked then s := s + 'B2';
  if rbCh04.Checked then s := s + 'B3';
  if rbCh05.Checked then s := s + 'B4';
  if rbCh06.Checked then s := s + 'B5';
  if rbCh07.Checked then s := s + 'B6';
  if rbCh08.Checked then s := s + 'B7';
  if rbCh09.Checked then s := s + 'B8';
  if rbCh10.Checked then s := s + 'B9';
  if rbCh11.Checked then s := s + 'BA';
  if rbCh12.Checked then s := s + 'BB';
  if rbCh13.Checked then s := s + 'BC';
  if rbCh14.Checked then s := s + 'BD';
  if rbCh15.Checked then s := s + 'BE';
  if rbCh16.Checked then s := s + 'BF';

  {Which Attrib?}
  s := s + '07';
  s := s + HexStr(UpDn3.Position, 2);

  labVolume.Caption := s
end;


function TForm1.VLN(var midIx: integer): LongInt;
{This decodes the "variable length number" from in the midi byte array
at index midIx}
var
  Hold, F, anInt: integer;
begin
  Hold := 0;
  for F := midIx to midIx + 3 do {I think VLNs can be only this big}
  begin
    anInt := midiArr[F];
    if anInt >= $80 then
    begin
      anInt := anInt and $7F; {'msb reset to 0}
      Hold := Hold + anInt;
      Hold := Hold * $80; {Move it right 7 bits to make room. There's more coming}
      inc(midIx); {Move index along 1}
    end
    else
    begin
       Hold := Hold + anInt;
       inc(midIx); {Move index along 1}
       Break; {Out of the for loop}
    end;
  end; {for F}
  Result := Hold;
end;

procedure TForm1.LoadMidiFile;
var
  aFile: file of byte;
  F: integer;
begin
  AssignFile(aFile, midiFileName);
  Reset(aFile);
  midArrLen := FileSize(midiFileName);
  SetLength(midiArr, midArrLen);
  sgMidiTable.RowCount := midArrLen + 1; { + 1 for the header row}

  For F := 0 to (FileSize(afile) - 1) do
  begin
    Read(afile, midiArr[F]);
    with sgMidiTable do
    begin
      Cells[0 ,F + 1] := intToStr(F);
      Cells[1 ,F + 1] := intToHex(midiArr[F], 2); {Hex}
      Cells[2 ,F + 1] := intToStr(midiArr[F]); {Dec}
      Cells[3 ,F + 1] := Char(midiArr[F]); {Chr}
    end;
  end;
  CloseFile(afile);

  labStatus.caption := 'File read in.';
  Form1.Caption := 'Midi 02 ' + midiFileName;
end;

procedure TForm1.LoadMidiFileClick(Sender: TObject);
begin

  OpenDialog1.Filter := 'Midi files|*.mid';
  if OpenDialog1.Execute then
     midiFileName := OpenDialog1.Filename
  else  exit;

  LoadMidiFile;
end;

procedure TForm1.OnProgramStart(Sender: TObject);
var aFile: TextFile;
    aStr: string;
    Index: integer;
begin
  {Load in the file of midi notes}
  AssignFile(aFile, '/home/pi/George/Midi02/Midi note table.txt');
  Reset(aFile); Index := 0;
  while not eof(aFile) do
  begin
    readln(aFile, aStr);
    MidiNoteVals[Index] := aStr;
    Index := Index + 1;
  end;
  CloseFile(afile);

  if SetCurrentDir('/home/pi/George/Midi02/Scores') then
    aStr := 'Good directory'; {For debugging}

  {Load in the file of midi notes}
  AssignFile(aFile, '/home/pi/George/Midi02/SC-88 Sound map.txt');
  Reset(aFile);    cbPatch.Items.Clear;
  Index := 0;
  while not eof(aFile) do
  begin
    readln(aFile, aStr);
    cbPatch.Items.Add(aStr);
    Index := Index + 1;
    InstArray[Index] := aStr;
  end;
  CloseFile(afile);

  {Init global variables}
  midArrLen := 0;
  midArrIx := 0;
  with sgMidiTable do
  begin
    ColWidths[0] := 90; {Pos}
    ColWidths[1] := 30; {Hex}
    ColWidths[2] := 40; {Dec}
    ColWidths[3] := 25; {Chr}
    ColWidths[4] := 250;{Comment}
    Options := [
      goFixedVertLine,
      goFixedHorzLine,
      goVertLine,
      goHorzLine,
     goRangeSelect];
  end;
  with sgEventTable do
  begin
    ColWidths[0] := 80; {Item}
    ColWidths[1] := 80; {Start time}
    ColWidths[2] := 60; {Delta time}
    ColWidths[3] := 45; {Send}
    ColWidths[4] := 45;{Cmd}
    ColWidths[5] := 45;{Note}
    ColWidths[6] := 45;{Velocity}
    ColWidths[7] := 45;{Sort}
    Options := [
      goFixedVertLine,
      goFixedHorzLine,
      goVertLine,
      goHorzLine,
      goRangeSelect];
  end;


  trackCount:= 0;
  LastEventIxToArduino:= 0;
  lbReceived.Color := $C0DCC0; {A greeny khaki}

  PageControl1.ActivePage := TabSheet1; {The Arduino tab}
  cbPatch.ItemIndex := 0; {Instrument}

  rgKeyboard.ItemIndex := 1; {0 Though, 1 Trigger}
  rgGuitar.ItemIndex := 1; {0 Though, 1 Trigger}

end;


procedure TForm1.GetChInst();
var Chn: integer;
    Inst, BankVar, InstInx, Volume: integer;
    aStr: string;
begin

  labChInst0.Caption := 'Chan 00';
  labChInst1.Caption := 'Chan 01';
  labChInst2.Caption := 'Chan 02';
  labChInst3.Caption := 'Chan 03';
  labChInst4.Caption := 'Chan 04';
  labChInst5.Caption := 'Chan 05';
  labChInst6.Caption := 'Chan 06';
  labChInst7.Caption := 'Chan 07';
  labChInst8.Caption := 'Chan 08';
  labChInst9.Caption := 'Chan 09';
  labChInst10.Caption := 'Chan 0A';
  labChInst11.Caption := 'Chan 0B';
  labChInst12.Caption := 'Chan 0C';
  labChInst13.Caption := 'Chan 0D';
  labChInst14.Caption := 'Chan 0E';
  labChInst15.Caption := 'Chan 0F';

  labVol0.Caption := '00';
  labVol1.Caption := '00';
  labVol2.Caption := '00';
  labVol3.Caption := '00';
  labVol4.Caption := '00';
  labVol5.Caption := '00';
  labVol6.Caption := '00';
  labVol7.Caption := '00';
  labVol8.Caption := '00';
  labVol9.Caption := '00';
  labVolA.Caption := '00';
  labVolB.Caption := '00';
  labVolC.Caption := '00';
  labVolD.Caption := '00';
  labVolE.Caption := '00';
  labVolF.Caption := '00';

  for EventIx := 1 to EventCount do
  begin
    with EventRecArray[EventIx] do begin
      {Getting the instrument}
      if Byte1 = $FF then
      begin
        Chn := Byte2 - $C0;
        case Chn of
          $0..$F: begin
            Inst := Byte3 + 1;
            BankVar := EventRecArray[EventIx - 2].Byte3;
          end;
        end;

        aStr := HexStr(Inst, 2) + ' ' + HexStr(BankVar, 2);
        for InstInx := 0 to 415 - 1 do
        begin
          if LeftStr(InstArray[InstInx], 5) = aStr then
          begin
            aStr := 'Chan ' + HexStr(Chn, 2) + '  ' + InstArray[InstInx];
            system.break;
          end;
        end;

        case Chn of
          $0: labChInst0.Caption := aStr;
          $1: labChInst1.Caption := aStr;
          $2: labChInst2.Caption := aStr;
          $3: labChInst3.Caption := aStr;
          $4: labChInst4.Caption := aStr;
          $5: labChInst5.Caption := aStr;
          $6: labChInst6.Caption := aStr;
          $7: labChInst7.Caption := aStr;
          $8: labChInst8.Caption := aStr;
          $9: labChInst9.Caption := aStr;
          $A: labChInst10.Caption := aStr;
          $B: labChInst11.Caption := aStr;
          $C: labChInst12.Caption := aStr;
          $D: labChInst13.Caption := aStr;
          $E: labChInst14.Caption := aStr;
          $F: labChInst15.Caption := aStr;
        end;
      end;
      if (Byte2 = $07) then
      begin {Initial volume setting}
        Chn := Byte1 - $B0;
        case Chn of
          $0..$F: begin
            Volume := Byte3;
            aStr := HexStr(Volume, 2);
            case Chn of
              $0: labVol0.Caption := aStr;
              $1: labVol1.Caption := aStr;
              $2: labVol2.Caption := aStr;
              $3: labVol3.Caption := aStr;
              $4: labVol4.Caption := aStr;
              $5: labVol5.Caption := aStr;
              $6: labVol6.Caption := aStr;
              $7: labVol7.Caption := aStr;
              $8: labVol8.Caption := aStr;
              $9: labVol9.Caption := aStr;
              $A: labVolA.Caption := aStr;
              $B: labVolB.Caption := aStr;
              $C: labVolC.Caption := aStr;
              $D: labVolD.Caption := aStr;
              $E: labVolE.Caption := aStr;
              $F: labVolF.Caption := aStr;
            end;
          end;
        end;
      end;
    end;
  end;
end;


procedure TForm1.btnChangeUsedChannelClick(Sender: TObject);
Const
  FromChn = $00;
  ToChn = $07;
var Cmd,
    Chn: integer;
begin
  for EventIx := 1 to EventCount do
  begin
    with EventRecArray[EventIx] do begin
      if Byte1 = $FF then begin
        Cmd := Byte2 and $F0;   {Most significant nybble}
        Chn := Byte2 and $0F;   {Lsn}
        if Chn = FromChn then Chn := ToChn;
        {And other channels if needed}
        Byte2 := Cmd + Chn;
      end;
      Cmd := Byte1 and $F0;   {Most significant nybble}
      Chn := Byte1 and $0F;   {Lsn}
      case Cmd of
        $80, $90, $B0, $C0: begin
          if Chn = FromChn then Chn := ToChn;
          {And other channels if needed}
          Byte1 := Cmd + Chn;
        end;
      end;
    end;
  end;
  DisplayEventGrid;
end;


procedure TForm1.btnGetChInstClick(Sender: TObject);
begin
  GetChInst;
end;

procedure TForm1.labFineVolumeClick(Sender: TObject);
Var Response: integer;
  s, Msg: String;
begin
  s := labFineVolume.Caption;
  Response := Application.MessageBox('Send?', 'Attributes', MB_ICONQUESTION + MB_YESNO);
  if Response <> IDYES then exit;
  if glSerialRunning then Transmit(s);
end;

procedure TForm1.labVolumeClick(Sender: TObject);
Var Response: integer;
  s, Msg: String;
begin
  s := labVolume.Caption;
  Response := Application.MessageBox('Send?', 'Attributes', MB_ICONQUESTION + MB_YESNO);
  if Response <> IDYES then exit;
  if glSerialRunning then Transmit(s);
end;

procedure TForm1.ParseArray(Sender: TObject);
var
  initArr: array [0..3] of char = ('M','T','h','d');
  trakArr: array [0..3] of char = ('M','T','r','k');
  holdMidArrIx: integer;
  int2byte: integer;
  int4byte: integer;
  aVLN: LongInt;
  Channel: byte;

begin
{1. Check that the midi file has been read in}
  if midArrLen = 0 then
  begin
    labStatus.caption := 'File not yet read in';
    exit;
  end;

{2. Is it a midi file? Check the first 4 bytes}
  midArrIx := 0;
  for midArrIx := midArrIx to midArrIx + 3 do
  begin
    if midiArr[midArrIx] <> ord(initArr[midArrIx]) then
    begin
      labStatus.caption := 'Not a valid midi file';
      exit;
    end;
  end;
  inc(midArrIx);
  sgMidiTable.Cells[4, midArrIx] := 'MThd is a valid midi file';
  Application.ProcessMessages;

{3. Now get value of next 4 bytes for the length of the rest of the header}
  {Not much use}
  int4byte := 0;
  for midArrIx := midArrIx to midArrIx + 3 do
  begin
    int4byte := (int4byte * 256) + midiArr[midArrIx];
  end;
  labStatus.caption := IntToStr(int4byte);
  inc(midArrIx);
  sgMidiTable.Cells[4, midArrIx] := 'Remaining length of header';

{4. Is it a type 1 midi file?}
  int2byte := 0;
  for midArrIx := midArrIx to midArrIx + 1 do
  begin
    int2byte := (int2byte * 256) + midiArr[midArrIx];
  end;
  if int2byte = 1 then
  begin
    labStatus.caption := 'Type 1 midi file ok';
    {Type 0 has only one track. Type 2 can be ignored}
  end
  else
  begin
    labStatus.caption := 'Not a type 1 midi file';
    exit;
  end;
  inc(midArrIx);
  sgMidiTable.Cells[4, midArrIx] := 'Is a type 1 midi file';

{5. How many tracks?}
  int2byte := 0;
  for midArrIx := midArrIx to midArrIx + 1 do
  begin
    int2byte := (int2byte * 256) + midiArr[midArrIx];
  end;
  trackCount:= int2byte;
  if trackCount = 0 then
  begin
    labStatus.caption := 'Zero tracks found';
    exit;
  end;
  inc(midArrIx);
  sgMidiTable.Cells[4, midArrIx] := 'Count of tracks';

  {Declaring the array of track-record types. }
  SetLength(trackRecArray, trackCount + 1); {All track records created here}
  {The trackRecArray is zero based but element 0 will not be used}
  trackIndex := 1;

{6. Tempo, clicksPerCrotchet}
  int2byte := 0;
  for midArrIx := midArrIx to midArrIx + 1 do
  begin
    int2byte := (int2byte * 256) + midiArr[midArrIx];
  end;
  clicksPerCrotchet := int2byte;
  labStatus.caption :=  inttostr(clicksPerCrotchet);
  inc(midArrIx);
  //sgMidiTable.Cells[4, midArrIx] := intToHex(clicksPerCrotchet, 4) + ' clicks per crotchet';
  sgMidiTable.Cells[4, midArrIx] := intToStr(clicksPerCrotchet) + ' clicks per crotchet';
  {Once the VLN is found, it is divided by clicksPerCrotchet and
   multiplied by 1000 to get the delay in milliseconds}

{7. Is there a track 1 header?}
  holdMidArrIx := midArrIx;
  for midArrIx := midArrIx to midArrIx + 3 do
  begin
    if midiArr[midArrIx] <> ord(trakArr[midArrIx - holdMidArrIx]) then
    begin
      labStatus.caption := 'Track ' +  intToStr(trackIndex) + ' header not found';
      exit;
    end;
  end;
  inc(midArrIx);
  sgMidiTable.Cells[4, midArrIx] := 'Track ' + intToStr(trackIndex) + ' header';

  trackIndex := 1;
  trackRecArray[trackIndex].trackStart := midArrIx - 4;

{8. Find the length of track 1
  This value is incorrect in about 50% of
  MIDI files, and should be ignored}
  int4byte := 0;
  for midArrIx := midArrIx to midArrIx + 3 do
  begin
    int4byte := (int4byte * 256) + midiArr[midArrIx];
  end;
  labStatus.caption := IntToStr(midArrIx);
  sgMidiTable.Cells[4, midArrIx] := 'Supposed length of track 1';
  inc(midArrIx);
  sgMidiTable.Cells[4, midArrIx] := 'last byte at pos ' +
    inttostr(midArrIx + int4byte - 1);
  labStatus.caption := IntToStr(midArrIx);
  trackRecArray[trackIndex].trackEnd := midArrIx -1;

  holdMidArrIx := midArrIx; //New code to find the beats per bar

  inc(midArrIx, int4byte); {Leap to the second track despite the advice}

    //New code to find the beats per bar
  for holdMidArrIx := holdMidArrIx + 1 to midArrIx -1 do
  begin
    if midiArr[holdMidArrIx] = $FF then
      if midiArr[holdMidArrIx + 1] = $58 then
      begin
         sgMidiTable.Cells[4, holdMidArrIx + 2] := 'Beats per bar ';
         BeatsPerBar := midiArr[holdMidArrIx + 3];
         sgMidiTable.Cells[4, holdMidArrIx + 4] := inttostr(BeatsPerBar);
         Break; {Exit for}
       end;
  end;

{9. Beginning of loop through the remaining tracks}
  EventCount := 0;
  for trackIndex := 2 to trackCount do
  begin
    holdMidArrIx := midArrIx;
    for midArrIx := midArrIx to midArrIx + 3 do {Is there a track header here?}
    begin
      if midiArr[midArrIx] <> ord(trakArr[midArrIx - holdMidArrIx]) then
      begin
        labStatus.caption := 'Track ' +  intToStr(trackIndex) + ' header not found';
        exit;
      end;
    end;
    inc(midArrIx);
    sgMidiTable.Cells[4, midArrIx] := 'Track ' + intToStr(trackIndex) + ' header';
    {Save the position of the track-start}
    trackRecArray[trackIndex].trackStart := midArrIx - 4;

{10. Where is the end of this track}
    int4byte := 0;
    for midArrIx := midArrIx to midArrIx + 3 do
    begin
      int4byte := (int4byte * 256) + midiArr[midArrIx];
    end;
    labStatus.caption := IntToStr(midArrIx);
    sgMidiTable.Cells[4, midArrIx] := 'Supposed length of this track';
    inc(midArrIx);
    sgMidiTable.Cells[4, midArrIx] := 'last byte at pos ' + inttostr(midArrIx + int4byte - 1);
    labStatus.caption := IntToStr(midArrIx);
    {Save the position of the track-end}
    trackRecArray[trackIndex].trackEnd := midArrIx  + int4byte - 1;

{11. Status messages until the end of the track}
    //inc(midArrIx);
    While midArrIx <= trackRecArray[trackIndex].trackEnd do
    begin
      {I presume everything in the track hereafter is preceded by timestamp}
      aVLN := VLN(midArrIx);
      sgMidiTable.Cells[4, midArrIx] := inttostr(aVLN) + ' timestamp';
      case midiArr[midArrIx] of
        $B0..$BF: begin
          sgMidiTable.Cells[4, midArrIx + 1] := 'Control/Mode change';
          sgMidiTable.Cells[4, midArrIx + 2] := '   just send';
          sgMidiTable.Cells[4, midArrIx + 3] := '   3 bytes';
          inc(midArrIx, 3);
        end;
        $C0..$CF: begin
          sgMidiTable.Cells[4, midArrIx + 1] := 'Instrument';
          sgMidiTable.Cells[4, midArrIx + 2] := '   change';
          inc(midArrIx, 2);
        end;
        $FF: begin {A meta event}
          sgMidiTable.Cells[4, midArrIx + 1] := 'Meta event';
          inc(midArrIx);
          sgMidiTable.Cells[4, midArrIx + 1] := '   number ' + intToStr(midiArr[midArrIx]);
          {Now follows a VLN which is the number of bytes to the end of the meta data}
          inc(midArrIx);
          aVLN := VLN(midArrIx);
          sgMidiTable.Cells[4, midArrIx] := '   leap of ' + intToStr(aVLN);
          inc(midArrIx, aVLN); {Go there}
        end;
        $80..$8F: begin {Note off data}
          Channel := midiArr[midArrIx] and $0F;
          sgMidiTable.Cells[4, midArrIx + 1] := 'Sound off channel ' + intToStr(Channel);
          inc(midArrIx);
          sgMidiTable.Cells[4, midArrIx + 1] := '  note';
          inc(midArrIx);
          sgMidiTable.Cells[4, midArrIx + 1] := '  volume';
          inc(midArrIx);
        end;
        $90..$9F: begin {Note on data}
          Channel := midiArr[midArrIx] and $0F;
          sgMidiTable.Cells[4, midArrIx + 1] := 'Sound on channel ' + intToStr(Channel);
          inc(midArrIx);
          sgMidiTable.Cells[4, midArrIx + 1] := '  note';
          inc(midArrIx);
          sgMidiTable.Cells[4, midArrIx + 1] := '  volume';
          inc(midArrIx);
        end;
      else
        inc(midArrIx)
      end;
    end;

    {Jump to the start of the next track}
    midArrIx := trackRecArray[trackIndex].trackEnd + 1
  end; {for trackIndex in Section 9}
  labStatus.caption := 'Parse completed.';
end; {ParseArray}

procedure TForm1.DisplayEventGrid();
begin
  with sgEventTable do
  begin
    RowCount := 1;  {Seems to help}
    RowCount := EventCount + 1;
    for EventIx := 1 to EventCount do
    begin
      with EventRecArray[EventIx] do begin
        Cells[0, EventIx] := IntToStr(EventIx);
        Cells[1, EventIx] := FloatToStr(RunningDelta);
        Cells[2, EventIx] := FloatToStr(DeltaTime);
        Cells[3, EventIx] := intToStr(BytesToSend);
        Cells[4, EventIx] := intToHex(Byte1, 2);
        Cells[5, EventIx] := intToHex(Byte2, 2);
        Cells[6, EventIx] := intToHex(Byte3, 2);
        Cells[7, EventIx] := intToStr(Sort);
        {Overwrite Sort with the note description}
        case Byte1 of
          $90..$9F: {Note on only}
          begin
            if Byte2 <= 120 then
              Cells[7, EventIx] := MidiNoteVals[Byte2];
          end
          else
            Cells[7, EventIx] := '';
        end;
      end;
    end;
  end;
end;

procedure TForm1.MakeNoteList(Sender: TObject);
var
  LocalRunningDelta: LongWord;
  aVLN: LongInt;
  //Millis: LongInt;

begin {Looking for notes to play}
  EventCount := 0; {Record 0 is not used}
  SetLength(EventRecArray, EventCount + 1);
  for trackIndex := 2 to trackCount do  {Loop through each track}
  begin
    trackRecArray[trackIndex].eventStart := EventCount + 1;
    midArrIx := trackRecArray[trackIndex].trackStart;
    inc(midArrIx, 8); {To get to the first timestamp}
    LocalRunningDelta := 0; {Reset for each track}
    //LocalRunningDelta := Millis * 2; {Reset for each track}
    //{Now loop until the end of the track}
    while midArrIx < trackRecArray[trackIndex].trackEnd do
    begin
      inc(EventCount); SetLength(EventRecArray, EventCount + 1);
      {The EventRecArray is zero based but element 0 will not be used}
      EventRecArray[EventCount].Sort := EventCount; {Preliminary only. Will be set later}
      {I presume everything in the track hereafter is prefixed by timestamp}
      aVLN := VLN(midArrIx);
      //aVLN := aVLN * 60;
      //aVLN := aVLN div StrToInt(edBPM.text);
      {aVLN := aVLN * 1000;
      aVLN := aVLN div clicksPerCrotchet;
      It is better to leave one second as 960 milliseconds
      It saves awkwardness, eg 412 being regarded as half 825
      This will speed-up the playback by a tiny amount}

      EventRecArray[EventCount].DeltaTime := aVLN;
      LocalRunningDelta := LocalRunningDelta + EventRecArray[EventCount].DeltaTime;
      EventRecArray[EventCount].RunningDelta := LocalRunningDelta;
      {I expect that midArrIx has been updated according to VLN byes used}

      case midiArr[midArrIx] of
        $B0..$BF: begin {Control/Mode change. Just send these 3 bytes}
          EventRecArray[EventCount].BytesToSend := 3;
          EventRecArray[EventCount].Byte1 := midiArr[midArrIx];
          inc(midArrIx);
          EventRecArray[EventCount].Byte2 := midiArr[midArrIx];
          inc(midArrIx);
          EventRecArray[EventCount].Byte3 := midiArr[midArrIx];
          inc(midArrIx);
        end;
        $C0..$CF: begin {Instrument change}
          EventRecArray[EventCount].BytesToSend := 3;
          EventRecArray[EventCount].Byte1 := $FF;
          EventRecArray[EventCount].Byte2 := midiArr[midArrIx];
          inc(midArrIx);
          EventRecArray[EventCount].Byte3 := midiArr[midArrIx];
          inc(midArrIx);
        end;
        $FF: begin {A meta event - which we ignore}
          {Now follows a VLN which is the number of bytes to the
           end of the meta data}
          inc(midArrIx,2);
          aVLN := VLN(midArrIx);
          inc(midArrIx, aVLN); {Go there}
          {Alas an event record has been created for this, so ...}
          dec(EventCount); {will see this is overwritten}
        end;
        $80..$9F: begin {Note on or off data}
          EventRecArray[EventCount].BytesToSend := 3;
          EventRecArray[EventCount].Byte1 := midiArr[midArrIx];
          inc(midArrIx);
          EventRecArray[EventCount].Byte2 := midiArr[midArrIx];
          inc(midArrIx);
          EventRecArray[EventCount].Byte3 := midiArr[midArrIx];
          inc(midArrIx);
        end;
        else
          inc(midArrIx)
      end; {Case}
    end; {While midArrIx}
    trackRecArray[trackIndex].eventEnd := EventCount;
  end; {for trackIndex}
  DisplayEventGrid;
  labStatus.caption := 'Note list completed.';
end; {MakeNoteList}

procedure TForm1.SortNoteListClick(Sender: TObject);
{Sort the EventRecArray by the RunningDelta field.
This is necessary because of multiple tracks.
If there is already an event for this time,
 the next one will have it's delta time reset to zero.
This is not a standard sort, but rather a zipping
together of two or more sorted lists, by RunningDelta.
We start at track 2. Each subsequent track is sorted into it.
}
var
  ItemPos1: integer; {A pointer for each track}
  ItemPos2: integer; {A pointer for the other tracks in turn}
  HoldEvent: EventType;
  HoldDelta: LongWord;
  PrevDelta: LongWord;
  HoldRunning: LongWord;
  DeltaCount: integer;

  //LocalRecArray: array of EventType;
  //Completed: boolean;
  //aStr: String;

begin
  {Bubble, recode later to do an efficiant zipping togethter}
  for ItemPos1 := EventCount downto 2 do
  begin
    for ItemPos2 := 2 to ItemPos1 do
    begin
      if EventRecArray[ItemPos2 - 1].RunningDelta >
        EventRecArray[ItemPos2].RunningDelta then
      begin
        HoldEvent := EventRecArray[ItemPos2 - 1];
        EventRecArray[ItemPos2 - 1] := EventRecArray[ItemPos2];
        EventRecArray[ItemPos2] := HoldEvent;
      end;
    end;
  end;

  //DisplayEventGrid; exit;

  {Remove the duplicated delta-times}
  HoldRunning :=  EventRecArray[1].RunningDelta;
  for ItemPos1 := 2 to EventCount do {1 done in the preceding line}
  begin
    EventRecArray[ItemPos1].DeltaTime := 0; {Default}
    if EventRecArray[ItemPos1].RunningDelta <> HoldRunning then
    begin {Redo the DeltaTime from the RunningDelta and the previous event}
      EventRecArray[ItemPos1].DeltaTime :=
        EventRecArray[ItemPos1].RunningDelta - HoldRunning;
      HoldRunning := EventRecArray[ItemPos1].RunningDelta;
    end;
  end; {Duplications gone}

  //DisplayEventGrid; exit;

  {Shifting them back to the start of their zero block}
  HoldDelta := 0;
  DeltaCount := 0; {Taking the oppunity in this loop to count these}
  for ItemPos1 := EventCount downto 1 do
  begin {Going backwards}
    if EventRecArray[ItemPos1].DeltaTime <> 0 then
    begin {Have found a delta}
      inc(DeltaCount); {For later}
      if HoldDelta = 0 then {Must be the last one in the list.
                             The first one actioned}
      begin
        HoldDelta := EventRecArray[ItemPos1].DeltaTime; {Get it}
        PrevDelta := HoldDelta;
        //EventRecArray[ItemPos1].DeltaTime := 1000; {An honourary number for Arduino's software}
        EventRecArray[ItemPos1].DeltaTime := $2222;
          {$2222 is about 8.7 seconds. Pleanty of time for the user
           to trigger a reload}
      end
      else
      begin
        {Something here}
        HoldDelta := EventRecArray[ItemPos1].DeltaTime; {Get it}
        EventRecArray[ItemPos1].DeltaTime := PrevDelta;
        PrevDelta := HoldDelta;
      end;
    end;
  end;
  {Fix up the one at the begining}
  EventRecArray[1].DeltaTime := PrevDelta;
  inc(DeltaCount);

  //DisplayEventGrid; Exit;

  {Delta-times are given their own event. This is so that the timer can be
   set, and the immeiate following zero-delta-time based events
   can be sent to the midi synth straight away, while the time
   is used up}
  SetLength(EventRecArray, EventCount + DeltaCount + 1);

  for EventIx := EventCount downto 1 do
  begin
    if EventRecArray[EventIx].DeltaTime <> 0 then
      {This is a record with a delta-time, and it is at
      the start of a block.}
    begin
      HoldRunning := EventRecArray[EventIx].RunningDelta;
      HoldDelta := EventRecArray[EventIx].DeltaTime;
      {These two form the basis of the timing record}

      for ItemPos1 := EventCount + DeltaCount downto EventIx + 1 do
      begin {Shuffle the trailing events along the array to make room}
        {Backwards as usual}
        EventRecArray[ItemPos1] := EventRecArray[ItemPos1 - 1];
      end;

      {Make up a delta event with milliseconds in the fields}
      with EventRecArray[EventIx] do
      begin
        RunningDelta := HoldRunning;
        DeltaTime := HoldDelta;
        BytesToSend := 0; {A flag to Arduino.
          It's a time and not for the synth}
        Byte1 := (HoldDelta and $FF0000) div $FFFF;
        Byte2 := (HoldDelta and $00FF00) div $FF;
        Byte3 := (HoldDelta and $0000FF);
        Sort := 1111;
      end;
      EventRecArray[EventIx + 1].DeltaTime := 0;
      //inc(EventCount);
      //DisplayEventGrid; Exit;
    end;
  end;
  EventCount := EventCount + DeltaCount; {Update global variable}

  DisplayEventGrid;
  labStatus.caption := 'Sorting completed.';
end; {SortNoteListClick}

procedure TForm1.btnSaveClick(Sender: TObject);
{This saves the grid. Delta time (as VLN), send, cmd and note
ready to be imported into Arduino-mega}
var
  fName: string;
  tfOut: TextFile;
begin

  if EventCount = 0 then
  begin
    ShowMessage('No events found to save.');
    exit;
  end;

  labStatus.caption := 'Saving';
  fName := leftStr(midiFileName, Length(midiFileName) - 3);
  fName := fName + 'Ard';
  {Catch errors in case the file cannot be created}
  try
    {Create text file, write to it and free it to prevent memory leaks}
    AssignFile(tfOut, fName);
    Rewrite(tfOut);
    for EventIx := 1 to EventCount do
       with EventRecArray[EventIx] do
       begin
         Write(tfOut, intToHex(BytesToSend, 2));
         Write(tfOut, intToHex(Byte1, 2));
         Write(tfOut, intToHex(Byte2, 2));
         Writeln(tfOut, intToHex(Byte3, 2));
       end;
    CloseFile(tfOut);
  except {Handle errors}
    on E:Exception do
      labStatus.caption := fName + ' not saved: ' +  E.Message;
  end;
  labStatus.caption := fName + ' created ok.';
end;

procedure TForm1.cbPatchChange(Sender: TObject);
var
  Chan, s: string;
  PC:integer;

begin
  {Which channel?}
  if rbCh01.Checked then Chan := '0';
  if rbCh02.Checked then Chan := '1';
  if rbCh03.Checked then Chan := '2';
  if rbCh04.Checked then Chan := '3';
  if rbCh05.Checked then Chan := '4';
  if rbCh06.Checked then Chan := '5';
  if rbCh07.Checked then Chan := '6';
  if rbCh08.Checked then Chan := '7';
  if rbCh09.Checked then Chan := '8';
  if rbCh10.Checked then Chan := '9';
  if rbCh11.Checked then Chan := 'A';
  if rbCh12.Checked then Chan := 'B';
  if rbCh13.Checked then Chan := 'C';
  if rbCh14.Checked then Chan := 'D';
  if rbCh15.Checked then Chan := 'E';
  if rbCh16.Checked then Chan := 'F';

  labInst1.Caption := '13B' + Chan + '00' + MidStr(cbPatch.Text, 4, 2);
  labInst2.Caption := '13B' + Chan + '2000';
  PC := Hex2Dec(MidStr(cbPatch.Text, 1, 2));
  PC := PC - 1;
  labInst3.Caption := '13FFC' + Chan + HexStr(PC, 2);
end;

procedure TForm1.FindNoteInList(Sender: TObject);
var HoldRow: longint;
  edStr: String;
  Found: boolean;

  procedure RunItFrom(This, That: LongInt);
  var F: LongInt;
    sgStr: string;
  begin
    with sgEventTable do
    begin
      For F := This + 1 to That do
      begin
        sgStr :=  sgEventTable.Cells[5, F];
        if sgStr = edStr then
        begin
        sgEventTable.Row := F;
          sgEventTable.Col := 5;
          sgEventTable.SetFocus;
          Found := True;
          Break;
        end;
      end;
    end;
  end;

begin
  edStr := edFindNoteInList.Text;
  if length(edStr) <> 2 then Exit;
  HoldRow := sgEventTable.Row;
  Found := false;
  RunItFrom(HoldRow, EventCount);
  if not Found then
    RunItFrom(1, HoldRow);

end;

procedure TForm1.SetInstrument(Sender: TObject);
Var Response: integer;
  s, Msg: String;
begin
  s := labInst1.Caption + labInst2.Caption + labInst3.Caption;
  Response := Application.MessageBox('Send?', 'Instrument', MB_ICONQUESTION + MB_YESNO);
  if Response <> IDYES then exit;

  if glSerialRunning then Transmit(s);
end;


procedure TForm1.ThroughOrTrigger;
var
  s: string;
begin
  case rgKeyboard.ItemIndex of
    0: s := '30zzzzzz'; {Through}
    1: s := '31zzzzzz'; {Trigger}
  end;
  Transmit(s);
  case rgGuitar.ItemIndex of
    0: s := '40zzzzzz'; {Through}
    1: s := '41zzzzzz'; {Trigger}
  end;
  Transmit(s);
  labStatus.Caption := 'Through, and-or trigger, sent to Arduino';
end;

procedure TForm1.rgKeyboardClick(Sender: TObject);
begin
  ThroughOrTrigger;
end;

procedure TForm1.rgGuitarClick(Sender: TObject);
begin
  ThroughOrTrigger;
end;

procedure TForm1.Transmit(s: string);
var
  status: LongInt;
  writecount: integer;
begin
  labStatus.Caption := s; Application.ProcessMessages;
  writecount := length(s);
  status := SerWrite(SerialHandle, s[1], writecount);
end;

procedure TForm1.SendIt;
{Assumes serial started. Send the first 400 records}
var
  s: String;
  b2, b3: byte;
  StartEvent: longInt;
begin
  if EventCount = 0 then
  begin
    ShowMessage('No note file loaded.');
    exit;
  end;

  {All records are 4 bytes long, as an 8 byte hex string}
  s := '060'; {Reset eIndexH & eIndexT,
    and send starting event-number in the next 5 nybbles (1,000,000) }
  {Starting event in edStartEvent}
  StartEvent := StrToInt(edStartEvent.Text);
  s := s + HexStr(StartEvent - 1, 5);
  Transmit(s);

  EventIx := 400;  {Hex 0190 is the usual count to request}
  //for EventIx := 1 to EventIx do {Only from the start of the array}
  for EventIx := StartEvent to StartEvent + 399 do
  begin
    with EventRecArray[EventIx] do
    begin
      s := FourByteStr(BytesToSend,
                        Byte1,
                        Byte2,
                        Byte3);
      Transmit(s);
      LastEventIxToArduino := EventIx;
    end;
    labStatus.Caption := s;
  end;
  labStatus.caption := 'Event array sent to Arduino.'
end;


procedure TForm1.btnSendClick(Sender: TObject);
begin
   AllSoundOff(Sender);
   SendIt;
   lbReceived.Clear;
end;


procedure TForm1.DisplayPacket(ComIn: string);
begin
  //An 8 byte packet has arrived - display it)
  lbReceived.Items.Add(ComIn);
end;


procedure TForm1.ActionAsk(ComIn: string);
var
  StartEvent, Many: longInt;
  s: string;
  b2, b3: byte;
begin
  if EventCount = 0 then
  begin
    ShowMessage('No file of notes loaded.');
    exit;
  end;

  StartEvent := Hex2Dec(midStr(ComIn, 3, 1));
  if StartEvent = 0 then {200zzzz as opposed to 201zzzz}
  begin
    StartEvent := 1;
    LastEventIxToArduino := 0;
    s := '0600'; {Reset eIndexH & eIndexT}
    b2 := EventRecArray[1].Byte2;
    b3 := EventRecArray[1].Byte3;
    s := s + HexStr(b2, 2) + HexStr(b3, 2);
    Transmit(s);
  end  else
  begin
     StartEvent := LastEventIxToArduino + 1;
  end;

  Many := Hex2Dec(RightStr(ComIn, 3));
  if  StartEvent + Many -1 > EventCount then
  begin
     Many := EventCount - StartEvent + 1;
  end;

  for EventIx := StartEvent to StartEvent + Many -1 do
  begin
    with EventRecArray[EventIx] do
    begin
      s := FourByteStr(BytesToSend,
                        Byte1,
                        Byte2,
                        Byte3);
      Transmit(s);
      LastEventIxToArduino := EventIx;
    end;
    labStatus.Caption := s;
  end;

  lbReceived.Items.Add(intToStr(EventIx));
end;

procedure TForm1.btnStartArduinoClick(Sender: TObject);
var
  ComPortName: String;
  Flags      : TSerialFlags; {TSerialFlags = set of (RtsCtsFlowControl);}
  status     : LongInt;
  ch         : Char;
begin
  ComPortName:= '/dev/ttyUSB0';
  //ComPortName:= '/dev/ttyACM0';
  labStatus.Caption := 'Using ' + ComPortname;

  SerialHandle := SerOpen(ComPortName); {Global varible}
  Flags:= [ ]; // None
  SerSetParams(SerialHandle, 9600, 8, NoneParity, 1, Flags);
  labStatus.Caption := 'Started.';
  labStarted.Color := clMoneyGreen;
  ThroughOrTrigger;

  {Start a perpetual loop}
  glSerialRunning := True;
  while glSerialRunning do {Looping in order to receive from arduino.
  A gui button-press will interrupt the loop.}
  begin
    {Application.ProcessMessages;}
    ch := #0;
    status := SerRead(SerialHandle, ch, 1);
    if (status > 0) then
    begin
      //ComIn := ComIn + ch;
      case ch of
        #10 : begin {Line feed, do nothing} end;
        #13 :
        begin //Cariage return
          lbReceived.Items.Add(ComIn);
          if (leftStr(ComIn, 2) = '20')
            and (length(ComIn) = 8) then
          begin {A request for more notes from Arduino}
            ActionAsk(ComIn);

          end;
          if (leftStr(ComIn, 2) = '21')
            and (length(ComIn) = 8) then
          begin {Arduino says 'display this packet'}
            DisplayPacket(ComIn);

          end;
          ComIn := '';
        end else
          ComIn := ComIn + ch;
      end;
      ch := #0;
    end;
    Application.ProcessMessages;
  end;
end;

procedure TForm1.SendNote();
var
  s: String;
begin
  s := '13'; {Three bytes for synth}
  s := s + intToHex(EventRecArray[EventIx].Byte1, 2);
  s := s + intToHex(EventRecArray[EventIx].Byte2, 2);
  s := s + intToHex(EventRecArray[EventIx].Byte3, 2);
  labStatus.Caption := s;
  Transmit(s);
end;

procedure TForm1.btnToSC88Click(Sender: TObject);
{Assumes serial started}
var
  s: String;
  aByte: byte;
begin
  {All records are 4 bytes long, as an 8 byte hex string}
  //s := '13FFC006'; {Change instrument to Harpsichord}
  //s := HexStr(cbPatch.ItemIndex, 2);
  //s := '13FFC0' + s;

  s := FourByteStr($13 {To synth}
                  ,$90 {note on}
                  ,$3C {Middle C4}
                  ,$7F); {Velocity middle range}
  Transmit(s);
  //s := FourByteStr($13 {To synth}
  //                ,$B2 {Control change on first channel}
  //                ,$49 {Attack}
  //                ,$10); {Value}
  //Transmit(s);
  labStatus.Caption := s;
end;

procedure TForm1.btnStopClick(Sender: TObject);
begin
  SerFlush(SerialHandle); {Discard any remaining output}
  SerClose(SerialHandle);
  glSerialRunning := False;
  labStatus.Caption := 'Stopped.';
  labStarted.Color := clRed;;

  {StopSerial;}
end;

procedure TForm1.ClearReceived(Sender: TObject);
begin
  lbReceived.Clear;
  ComIn := '';
end;

procedure TForm1.btnQuickStartClick(Sender: TObject);
begin
  //midiFileName := 'C:\George\Midi02\Recorder duet.mid';
  midiFileName := '/home/pi/George/Midi02/Recorder duet.mid';
  LoadMidiFile;

end;

procedure TForm1.btnPauseClick(Sender: TObject);
{Sends the sorted note array to the arduino
It assumes serial has started}
var
  s: String;
begin
  s := '040zzzzz'; {Stop playing}
  Transmit(s);
end;

procedure TForm1.btnPollAnalogClick(Sender: TObject);
{Assumes serial started}
var
  s: String;
begin
  {All records are 4 bytes long, as an 8 byte hex string}
  s := '0500A' + HexStr(0, 1) + 'zz'; {Analog port naught}
  Transmit(s);
  labStatus.Caption := s;
end;

procedure TForm1.btnQuickLoadClick(Sender: TObject);
begin
  AllSoundOff(Sender);
  LoadNoteList;
  if glSerialRunning then SendIt;
  lbReceived.Clear;
end;

procedure TForm1.btnOnClick(Sender: TObject);
var
  s: String;
begin
  //Turn on led at CheckIncomingport 35
  s := '0501' + HexStr(35, 2) + '01';

  Transmit(s);
end;

procedure TForm1.btnOffClick(Sender: TObject);
var
  s: String;
begin
  //Turn on led at port 35
  s := '0501' + HexStr(35, 2) + '00';
  Transmit(s);
end;

procedure TForm1.LoadNoteList;
var
  aFile: TextFile;
  noteFileName: string;
  aStr: string;
  RunningTime: longInt;
begin

  OpenDialog1.Filter := 'Note files|*.Ard';
  if OpenDialog1.Execute then
     noteFileName := OpenDialog1.Filename
  else exit;

  AssignFile(aFile, noteFileName);
  Reset(aFile);
  edStartEvent.Text := '1';

  EventCount := 0; {But not using element 0}
  RunningTime := 0;
  while not eof(aFile) do
  begin
    readln(aFile, aStr);
    inc(EventCount);
    SetLength(EventRecArray, EventCount + 1);
    with EventRecArray[EventCount] do
    begin
      BytesToSend := Hex2Dec(leftStr(aStr, 2));
      Byte1 := Hex2Dec(midStr(aStr, 3, 2));
      Byte2 := Hex2Dec(midStr(aStr, 5, 2));
      Byte3 := Hex2Dec(rightStr(aStr, 2));
      {Reconstruct these}
      if BytesToSend = 0 then
      begin
        DeltaTime := Byte1 * 65536;
        DeltaTime := DeltaTime + Byte2 * 256;
        DeltaTime := DeltaTime + Byte3;
        RunningTime := RunningTime + DeltaTime;
        RunningDelta := RunningTime;
      end;
    end; {With}
  end;
  CloseFile(afile);
  DisplayEventGrid();
  labStatus.caption := 'File read in.';
  Form1.Caption := 'Midi 02 ' + noteFileName;

  labChInst0.Caption := 'Chan 00';
  labChInst1.Caption := 'Chan 01';
  labChInst2.Caption := 'Chan 02';
  labChInst3.Caption := 'Chan 03';
  labChInst4.Caption := 'Chan 04';
  labChInst5.Caption := 'Chan 05';
  labChInst6.Caption := 'Chan 06';
  labChInst7.Caption := 'Chan 07';
  labChInst8.Caption := 'Chan 08';
  labChInst9.Caption := 'Chan 09';
  labChInst10.Caption := 'Chan 0A';
  labChInst11.Caption := 'Chan 0B';
  labChInst12.Caption := 'Chan 0C';
  labChInst13.Caption := 'Chan 0D';
  labChInst14.Caption := 'Chan 0E';
  labChInst15.Caption := 'Chan 0F';

end;

procedure TForm1.btnLoadNoteListClick(Sender: TObject);
begin
  AllSoundOff(Sender);
  LoadNoteList;
  lbReceived.Clear;
end;

procedure TForm1.btnFindClick(Sender: TObject);
var HoldRow: longint; {Find Hex in the midi grid}
  edStr: String;
  Found: boolean;

  procedure RunItFrom(This, That: LongInt);
  var F: LongInt;
    sgStr: string;
  begin
    with sgMidiTable do
    begin
      For F := This + 1 to That do
      begin
        sgStr :=  sgMidiTable.Cells[1, F];
        if sgStr = edStr then
        begin
          sgMidiTable.Row := F;
          sgMidiTable.Col := 1;
          sgMidiTable.SetFocus;
          Found := True;
          Break;
        end;
      end;
    end;
  end;

begin
  edStr := edFind.Text;
  if length(edStr) <> 2 then Exit;
  HoldRow := sgMidiTable.Row;
  Found := false;
  RunItFrom(HoldRow, midArrLen);
  if not Found then
    RunItFrom(1, HoldRow);
end;

procedure TForm1.AllSoundOff(Sender: TObject);
var s: string;
    Chan: integer; {Each channel}
begin
  labStatus.Caption := 'All sound off.';
  if glSerialRunning then
  begin
    for Chan := 0 to 15 do {Turn off each channel in turn}
    begin
      s := '13B' + HexStr(Chan, 1) + '7B00'; {Channel message 123}
      labStatus.Caption := s;
      Transmit(s);
    end;
  end;
  //labStatus.Caption := 'All sound off.';
end;

procedure TForm1.btnFindNoteClick(Sender: TObject);
var HoldRow: longint; {Actually, It's find a cmd in the note list}
  edStr: String;
  Found: boolean;

  procedure RunItFrom(This, That: LongInt);
  var F: LongInt;
    sgStr: string;
  begin
    with sgEventTable do
    begin
      For F := This + 1 to That do
      begin
        sgStr :=  sgEventTable.Cells[4, F];
        if sgStr = edStr then
        begin
          sgEventTable.Row := F;
          sgEventTable.Col := 4;
          sgEventTable.SetFocus;
          Found := True;
          Break;
        end;
      end;
    end;
  end;

begin
  edStr := edFindNote.Text;
  if length(edStr) <> 2 then Exit;
  HoldRow := sgEventTable.Row;
  Found := false;
  //RunItFrom(HoldRow, midArrLen);
  RunItFrom(HoldRow, EventCount);
  if not Found then
    RunItFrom(1, HoldRow);
end;


procedure TForm1.labAttribClick(Sender: TObject);
Var Response: integer;
  s, Msg: String;
begin
  s := labAttrib.Caption;
  Response := Application.MessageBox('Send?', 'Attributes', MB_ICONQUESTION + MB_YESNO);
  if Response <> IDYES then exit;
  if glSerialRunning then Transmit(s);
end;


procedure TForm1.PlayNoteListClick(Sender: TObject);
{Sends the sorted note array to the arduino
It assumes serial has started}
var
  s: String;
begin
  s := '041zzzzz'; {040zzzzz turns it off}
  Transmit(s);

  //writecount := length(s);
  //status := SerWrite(SerialHandle, s[1], writecount);

end;

end.

(*
An 8 char string is sent as a packet to arduino. One nibble per char.
Each pair is a hex string, so in effect it represents 4 bytes

Str[1] is the address of the device on the network
  0 For the Arduino
  01 Arduino to put remaining nybble and 3 bytes into the event array
    at its next eIndexH position
  02 same
  03 same
  040 Stop/pause playing
  041 Auto-play the event array
  05 A call for a change in a ports outward, or poll analog value
  05XX the pin's number
  0500XXzz Peek port pin value
  0501XX00 Poke port pin low
  0501XX01 Poke port pin high
  060HHHHH Reset eIndexH and eIndexT. A million events
  0701 Adjust the channel balance array
  07010CVV where 0C is the channel and VV is the adjustment to velocity
    The final velocity must be in the range 0 ... 127
    The Arduino's balance array is reset to 0 when loading

  1 For first midi device, the synth
  11 Arduino send following 1 byte straight to midi device
  12 send following 2 bytes
  13 send following 3 bytes
  2 The number of the Rasperry Pi
  200zz190 Send first 400 records from the note array
  201zzzC8 Send next 200 records
  21zzzzzz Display this packet
  3 The number of the keyboard
  30zzzzzz Tell the arduino that the
    keyboard is to be put through to Sc-88 (Default)
  31zzzzzz Keyboard is trigger only
  4 The number of the guitar GL-10
  40zzzzzz Tell the arduino that the
    guitar is to be put through to Sc-88 (Default)
  41zzzzzz Guitar is trigger only


*)